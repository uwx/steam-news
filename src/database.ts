/**
 * This file was generated by kysely-codegen.
 * Please do not edit it manually.
 */

import type { ColumnType, Insertable, InsertObject, Selectable } from "kysely";

import { GetOptions, Level } from 'level';
import fromAsync from 'array-from-async';

export interface Game {
    appid: string;
    name: string;
    shouldFetch: boolean;

    expiry_unix_seconds?: number;
}

export interface NewsItem {
    gid: string;
    title: string;
    url: string;
    is_external_url: boolean;
    author: string;
    contents: string;
    feedlabel: string;
    date: number;
    feedname: string;
    feed_type: number; // 0=HTML, 1=BBCODE
    appid: number;
    tags: string[];
    realappid: number;

    source_appids: number[];
}

import type { AppNewsItem } from "./index.js";

export class NewsDatabase {
    private db?: Level;
    constructor(private path: string) {}

    async open() {
        if (!this.db) {
            console.log(`Opening DB @ ${this.path}`);
            this.db = new Level('steam_news.ldb', { valueEncoding: 'json' });
            // await sql`'PRAGMA foreign_keys = ON'`.execute(this.db);
        }
    }

    async close(optimize = true) {
        if (this.db) {
            await this.db.close();
            this.db = undefined;
            this.sublevels = {};
        }
    }

    async [Symbol.asyncDispose]() {
        await this.close();
    }

    private sublevels: Record<string, any> = {};

    private get games() {
        if (!this.db) throw new Error('DB not initialized');

        return this.db.sublevel<string, Game>('games', {
            keyEncoding: 'utf8',
            valueEncoding: 'json'
        });
    }

    private get newsItems() {
        if (!this.db) throw new Error('DB not initialized');

        return this.db.sublevel<string, NewsItem>('news_items', {
            keyEncoding: 'utf8',
            valueEncoding: 'json'
        });
    }

    // Given a dict of appid: name, populate them in the database.
    async addGames(games: Record<number, string>) {
        if (!this.db) throw new Error('DB not initialized');

        await this.games.batch(Object.entries(games).map(([appid, game]) => ({
            type: 'put',
            key: appid,
            value: {
                appid,
                name: game,
                shouldFetch: true,
                expiry_unix_seconds: undefined,
            }
        })));

        console.log('addGames');
    }

    async removeGamesNotInList(appids: (string | number)[]) {
        if (!this.db) throw new Error('DB not initialized');

        appids = appids.map(e => String(e));

        await this.games.batch(
            (await fromAsync(this.games.keys()))
                .filter(appid => !appids.includes(appid))
                .map(appid => ({
                    type: 'del',
                    key: appid
                }))
        );

        console.log('removeGamesNotInList');
    }

    async *getGamesLike(name: string) {
        if (!this.db) throw new Error('DB not initialized');

        name = name.trim().replace(/%/g, '').toLowerCase();

        for await (const [appid, game] of this.games.iterator()) {
            if (game.name.toLowerCase().includes(name)) {
                yield game;
            }
        }
    }

    async setFetchingIds(appidsAndShouldFetch: [appid: number, shouldFetch: boolean][]) {
        if (!this.db) throw new Error('DB not initialized');

        const appidsDict = Object.fromEntries(appidsAndShouldFetch);

        for await (const [appid, game] of this.games.iterator()) {
            if (appid in appidsDict) {
                game.shouldFetch = appidsDict[appid];
                await this.games.put(appid, game);
            }
        }

        console.log('setFetchingIds');
    }

    async getOrDefault<K, V>(level: { get(key: K, options: GetOptions<K, V>): Promise<V> }, key: K, options: GetOptions<K, V> = {}) {
        try {
            return await level.get(key, options);
        } catch (err) {
            if (!((typeof err === 'object' || typeof err === 'function') && err !== null && 'code' in err && err.code === 'LEVEL_NOT_FOUND')) {
                throw err;
            }
            return undefined;
        }
    }

    async canFetchGames(appids: (string | number)[]) {
        if (!this.db) throw new Error('DB not initialized');

        for (const appid of appids) {
            const game = await this.getOrDefault<string, Game>(this.games, String(appid));
            if (game?.shouldFetch) return true;
        }

        return false;
    }

    async *getFetchGames() {
        if (!this.db) throw new Error('DB not initialized');

        for await (const [appid, game] of this.games.iterator()) {
            if (game.shouldFetch) {
                yield [appid, game] as const;
            }
        }

        console.log('getFetchGames');
    }

    async *getGames(appids: (string | number)[]): AsyncGenerator<Game> {
        for (const appid of appids) {
            const game = this.getOrDefault<string, Game>(this.games, String(appid));
            // @ts-expect-error fuck you
            if (game) yield game;
        }
    }

    async updateExpireTime(appid: string | number, expires: number) {
        if (!this.db) throw new Error('DB not initialized');

        const game = await this.games.get(String(appid));
        game.expiry_unix_seconds = Math.max(game.expiry_unix_seconds ?? 0, expires);
        await this.games.put(String(appid), game);
    }

    async isNewsCached(appid: string | number) {
        if (!this.db) throw new Error('DB not initialized');

        const game = await this.games.get(String(appid));

        // TODO maybe use datetime.timestamp() & now() instead?
        return game.expiry_unix_seconds !== undefined && (Date.now() / 1000) < game.expiry_unix_seconds;
    }

    async insertNewsItem(ned: AppNewsItem) {
        if (!this.db) throw new Error('DB not initialized');

        const existingNewsItem = await this.getOrDefault<string, NewsItem>(this.newsItems, ned.gid);

        const ned1 = {...ned};
        // @ts-expect-error
        delete ned1.realappid;

        await this.newsItems.put(ned.gid, {
            ...(existingNewsItem ? existingNewsItem : {}),
            ...ned1,
            source_appids: [...new Set([...(existingNewsItem?.source_appids ?? []), ned.realappid])]
        });
    }

    async *getNewsRows() {
        if (!this.db) throw new Error('DB not initialized');

        let thirtyago = new Date();
        thirtyago.setDate(thirtyago.getDate() - 30);

        const newsItems = this.newsItems;

        const result = await fromAsync((async function*() {
            for await (const [gid, newsItem] of newsItems.iterator()) {
                if (new Date(newsItem.date * 1000) >= thirtyago) {
                    yield newsItem;
                }
            }
        })());

        // sort by date desc
        return result.sort((a, b) => b.date - a.date);
    }
}